104.二叉树最大深度
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if root:
            return max(1+self.maxDepth(root.left),1+self.maxDepth(root.right))
        else:
            return 0
226.翻转二叉树
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def invertTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        if root:
            l,r = root.left,root.right
            root.left = r
            root.right = l
            self.invertTree(root.right)
            self.invertTree(root.left)
            return root
            
617合并二叉树
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def mergeTrees(self, t1, t2):
        """
        :type t1: TreeNode
        :type t2: TreeNode
        :rtype: TreeNode
        """
        if not t1 and not t2:
            return None
        if not t1 and t2:
            return t2
        if t1 and not t2:
            return t1
        if t1 and t2:
            t1.val = t1.val + t2.val
            t1.left = self.mergeTrees(t1.left,t2.left)
            t1.right = self.mergeTrees(t1.right,t2.right)
            return t1
938二叉搜索树范围和
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def rangeSumBST(self, root, L, R):
        """
        :type root: TreeNode
        :type L: int
        :type R: int
        :rtype: int
        """   
        ans = 0
        stack = [root]
        while(stack!=[]):
            r = stack.pop(0)
            if r.val <= R and r.val >=L:
                ans = ans + r.val
            if r.val < R:
                if r.right!=None:
                    stack.append(r.right)
            if r.val > L:
                if r.left!=None:
                    stack.append(r.left)
        return ans 
                
112路径总和
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def hasPathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """
        def tree_val(node,val):
            if node:
                val+=node.val
                if node.left!=None or node.right!=None:
                    return tree_val(node.left,val) or tree_val(node.right,val)
                else:
                    if val == sum:
                        return True
                    else:
                        return False
            else:
                return False
        return tree_val(root,0)
            
129.求根到叶子节点数字之和
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def sumNumbers(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.v = 0
        def tree_path(node,nn):
            if node:
                if node.left == None and node.right == None:
                    self.v += nn*10+node.val
                tree_path(node.left,nn*10+node.val)
                tree_path(node.right,nn*10+node.val)
        tree_path(root,0)
        return self.v
113路径总和Ⅱ
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def pathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: List[List[int]]
        """
        def tree_val(node,val,path):
            if node:
                val = node.val + val
                if node.left!=None or node.right!=None:
                    #path = path + ','
                    tree_val(node.left,val,path+[node.val])
                    tree_val(node.right,val,path+[node.val])
                else:
                    if val == sum:
                        paths.append(path+[node.val])
                       # print(path)
        paths = []
        tree_val(root,0,[])
    
        return paths
       
